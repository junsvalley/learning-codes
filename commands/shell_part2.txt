ps -e    -> all programmes on this HOST 
ps -f    -> formating the display, show the tree structure 
ps a     -> all programs on this TERNIMAL, include all users 
ps u     -> include user information 
ps x     -> all programs, not only on this terminal, also on other terminals
df -h    -> human readable 
df -a    -> all 
df -k    -> 1k blocks
rpm     -> redhat package manager, install/uninstall packages
ldd ldconfig export LD_LIBRARY_PATH=/usr/local/confd/lib
nm libconfd.so     -> show symbols in the files

#find suid and guid 
  ls -l | grep '^...s..s'
#change owner and group 
  chown -R -h new_owner file_name 
	#-R same to subdirectory
	#-h symbol link target not changed chgrp new_group file_name
#find groups,id,user's group groups
  id
  groups
  user_name
#umask umask & file_permission = 0
  umask & directory_permission = 0
#soft symbol link 
  ln [-s] source_path target_path
#find files
  find . -name "[A-Z][0-9].log" -print  #such as A0.log
  find . -mtime -5 "*" #all files modified in 5 days
  find . -type f -ctime +5 -exec rm {} \; #delete files created more than 5 
days

  find . -name "*.sh" | xargs chmod o-x
#crontab usage: min hour day month weekday commands
  15,20,30 11 * * * echo `date` >> /home/fbgu/src/shell/log.txt #file mycron 
  crontab mycron   #deliver my cron
  crontab -r       #remove the cron
  crontab -l       #list my cron
  echo `more * >> logs.txt` | at now +1 minute
  at 6.45pm Otc14 -f /home/fbgu/src/shell/db_table.sh #exec shell script
#clear logs nohup psl & #nohup deliver the clear process psl under background
#ls command 
  ls f??.log      #match ftp.log, fat.log etc.
  ls [0-1ao].log  #match 0.log, 1.log, a.log, o.log
  ls [!0-1ao].log #match files in addition to above 4 log files
  ls [0-9a-zA-Z]*.log  #match strings componented by character & numberic
#tee cat grep sort 
  tee -a files #-a append after the last line of the files
  cat -v #-v store into the cache firstly, then print out
  grep -v #-v filter the lines which are matched
  egrep -f strings file #egrep can save the records
  sort < files.in > files.out #sort the content
#awk
  awk -F seperator 'command' files #space seperator can remove the option 
  awk 'BEGIN {print index("Bunny", "ny")}' files #print sub string index 
  awk string functions: gsub, index, length, split, substr, match, sub etc. 
  awk 'BEGIN {print "\141"}' #\ddd octonary ASCII code, \141 is 'a'
#awk script example
  #!/bin/awk -f
  BEGIN{FS = ":"}
  MAX = 7  #NF variable MAX
  if ($0 == "ERROR*"){ next } #go to next line
  if (NF != MAX){print("line " NR " does not have " MAX " fields")
#sed command 
  sed -n '1,$p' file #1,$ all lines, $ means the last line
  sed -f sed.script file #-f to use sed script
  sed -n -e '/pattern/p' -e '/pattern/=' file #print the line and the line 
number

  sed '/pattern/ a\strings' file #'a\' append strings after the matched lines 
sed '4 i\strings' file         #'i\' append strings after the line number 4 
sed '/pattern/ c\strings' file #'c\' replace the matched lines with strings 
sed '1,3d' file #delete 1~3lines, '$d' delete last, '//d' delete the matched 
sed '1,3s/old_pattern/new_pattern/g' #replace all matched strings in 1~3lines 
sed 's/str1/str2/w sed.out' file #output the replaced lines into file sed.out 
sed 's/yes/Oh&/p' file #& store yes, so yes is replaced by Ohyes

  sed '/pattern/r input.txt' file #append match lines with content of input.
txt sed '/pattern/q' file #match the first one then quit

  sed -n '1,$l' file #l(Low case of L) show the control character of all 
lines sed "s/GO/$var/g" #in SHELL script, must use the double quote to use 
var sed 's/^\s\{2,\}//g' #delete the begin space or tab which more than 2 or 2

#sort command 
  sort -u source_file > target_file #sort and delete the repeat lines
  sort -t: source_file > target_file #split the line with :
  sort -r source_file > target_file #reverse the sorted lines
  sort -k4 source_file > target_file #sort by the field 4
  head -2 source_file #show the first 2 lines
  tail -2 source_file #show the last 2 lines
  sort -m file1 file2 #merge the 2 files
#uniq, join, cut, paste commands 
  uniq [-option] myfile #remove the continuous copy lines
       -u #only show the unrepeated lines
       -c #show the occured numbers
       -d #only show the repeated lines
       -f1, -f2, -f3 ... #ingore the first 1 or 2 or 3 fields join file1 
file2 #file1 field0 must be same with file2 field0

  join -j1 1 -j2 1 file1 file2 #indicate the same fields position
  join -o 1.1 2.2 file1 file2 #1.1 file1 field0, 2.2 file2 field1
  cut -c1-4 myfile #cut the first four characters
  cut -d: -f3 myfile #use : to split the lines, and get the field 3 
  paste -d: file1 file2 #paste the file2 lines after file1 lines with ":"
  paste -s file1 file2 #two lines, pasts as row, one file one row
  ls | paste - - #list as two columns, '- - -' 3 columns
  split -100 myfile #split it to several files, each file 100 lines
#tr command 
  tr -s "[a-z]" < file.txt #remove the repeated character
  tr -s "[\012]" < file.txt #delete the blank line, same to use \n
  tr "[a-z]" "[A-Z]" < file.txt #all change to upper case
  tr "[:lower:]" "[:upper:]" < file.txt #all change to upper case
  tr -sc "[a-z][A-Z]" "[\012*]" < file.txt #-c keep all characters
  tr -d "[a-z]" < file.txt #delete the dedicated characters
  tr "[a-j]" "[0-9]" < file.txt #a-0,...j-9 replaced one by one
  tr "[0*4]" "[*]" < file.txt #0*4 match 0000, a*3 match aaa
#shell variable 
  echo "The color is ${COLOR+grey}"  #if color is set, then use grey as 
temporary 

  echo "The color is ${COLOR:-grey}" #if not set color, print grey
  echo "The color is ${COLOR:=grey}" #if not set color, set COLOR grey and 
print 

  echo "The color is ${COLOR?s_err}"  #if not set color, print sys err 
  echo "The color is ${COLOR:?u_err}" #if not set color, print user defined 
err 

  read MYDATE #read from command line
  readonly MYDATE #cannot be changed
  export MYENV #set enviroment variable
  unset MYVAR #delete the variable
#test condition 
  test condition or [ condition ]
  [ condition1 -o condition2 ] #-o or, -a and
  test -w "$file"   #-w writable, -r readable, -x executable
  [ -d "$file" ]    #-d directory ok, -f file ok, -s file not 0 size, -L 
symbol link

  [ "$string1" = "$string2"] #= equal, != not equal, ! not true
  [ "$number1" -eq "$number2" ] #-eq,-ne,-gt,-lt,-ge,-le
  expr 30 \* 3 #\* to use *
  expr $hello = "hello" #exit status is 1 if true
  expr account.doc : "\(.*\).doc" #get account
#shell script 
  if [ -z "`ls -A $MYDIRECTORY`" ]; then ... #check if my directory is empty 
#!/bin/sh

  DEFAULT_IFS=$IFS;
  IFS=:
  while read NAME DEPT ID
  do case $NAME in  #case structor
    James|Tom) echo "";;
    *)echo"";;
    esac done < names.txt   #read NAME DEPT ID from file names.txt, IFS is :
  IFS=$DEFAULT_IFS
  break #end the loop
  break 2 #end the inner loop and outer loop
  continue #to the next loop
  while :  #endless loop
  set findit=(){find / -name $1 -print} #define findit just like enviroment
#shift, getopts shift #shift the command line arguments
  getopts #getopts OPTION=>option OPTAGR=>value
  while getopts :ablvf: OPTION #usage
#Advanced Usage set -x #debug the script
  cat >> myfile << NEWFILE #create file quickly, end when input NEWFILE 
traceroute $DEST_HOST > $trace_log 2>&1

  if grep "unknow host" $trace_log > /dev/null then... #check connectivity of 
DEST_HOST 

  ftp -i -n $DEST_HOST << FTPCONTENT #-i -n means not need to login 
automatically

  user anonymous $user@$thishost
  $transfer_mode #1 binary 2 ASCII
  get $file_name $my_directory/$file_name.ftp #get the file from DEST_HOST 
FTPCONTENT #end of the block

  kill -s SIGKILL $UPID #kill -9 $UPID Several import signals: 1 SIGUP, 2 
SIGINT, 3 SIGQUIT, 15 SIGTERM trap "commands" 2 3 #if 2 or 3 captured, exec 
the commands

  eval "cat myfile" #eval can exec the double quoted command 'cat'
  $(eval echo \$$#) #echo the last argument
  eval `echo ${NAME}=0` #define variable GO=0 if $NAME = GO
  du -a | cut -f1 #-a list the occupied size on disk
#Linux Shell Commands compress filename 
  dircmp dir1 dir2  #show the different of two directories, -s only show diff 
files

  file filename     #return file type
  fuser filename    #show the process which is using this file, -k kill the 
process

  nl filename       #show each line number
  logname           #print the logname
  strings binary_f  #check the strings in binary file
  uname             #get system type 'Linux' or 'Unix'
  tty               #get the connected device or terminal
  wc [-l|c|w] file  #get total line number, bytes, words
  whereis cmd_name  #get path of cmd, such as 'whereis fuser'
  who [-a|s|r]      #get all user | name, time etc. | show run 
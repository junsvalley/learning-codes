/**************************************  
 *
 *  shell commands
 *
 **************************************/
#Notes_Linux_Shell Part1

ps -e    -> all programmes on this HOST
ps -f    -> formating the display, show the tree structure
ps a     -> all programs on this TERNIMAL, include all users
ps u¡¡¡¡ -> include user information
ps x     -> all programs, not only on this terminal, also on other terminals



df -h    -> human readable
df -a    -> all
df -k    -> 1k blocks

rpm     -> redhat package manager, install/uninstall packages

ldd
ldconfig
export LD_LIBRARY_PATH=/usr/local/confd/lib

nm libconfd.so     -> show symbols in the files

#find suid and guid
  ls -l | grep '^...s..s'

#change owner and group
  chown -R -h new_owner file_name
       #-R same to subdirectory
       #-h symbol link target not changed
  chgrp new_group file_name

#find groups,id,user's group
  groups
  id
  groups user_name

#umask
  umask & file_permission = 0
  umask & directory_permission = 0

#soft symbol link
  ln [-s] source_path target_path

#find files
  find . -name "[A-Z][0-9].log" -print  #such as A0.log
  find . -mtime -5 "*" #all files modified in 5 days
  find . -type f -ctime +5 -exec rm {} \; #delete files created more than 5 days
  find . -name "*.sh" | xargs chmod o-x

#crontab usage: min hour day month weekday commands
  15,20,30 11 * * * echo `date` >> /home/fbgu/src/shell/log.txt #file mycron
  crontab mycron   #deliver my cron
  crontab -r       #remove the cron
  crontab -l       #list my cron
  echo `more * >> logs.txt` | at now +1 minute
  at 6.45pm Otc14 -f /home/fbgu/src/shell/db_table.sh #exec shell script

#clear logs
  nohup psl & #nohup deliver the clear process psl under background

#ls command
  ls f??.log      #match ftp.log, fat.log etc.
  ls [0-1ao].log  #match 0.log, 1.log, a.log, o.log
  ls [!0-1ao].log #match files in addition to above 4 log files
  ls [0-9a-zA-Z]*.log  #match strings componented by character & numberic

#tee cat grep sort
  tee -a files #-a append after the last line of the files
  cat -v #-v store into the cache firstly, then print out
  grep -v #-v filter the lines which are matched
  egrep -f strings file #egrep can save the records
  sort < files.in > files.out #sort the content

#awk
  awk -F seperator 'command' files #space seperator can remove the option
  awk 'BEGIN {print index("Bunny", "ny")}' files #print sub string index
  awk string functions: gsub, index, length, split, substr, match, sub etc.
  awk 'BEGIN {print "\141"}' #\ddd octonary ASCII code, \141 is 'a'

#awk script example
  #!/bin/awk -f
  BEGIN{FS = ":"}
  MAX = 7  #NF variable MAX
  if ($0 == "ERROR*"){ next } #go to next line
  if (NF != MAX){print("line " NR " does not have " MAX " fields")

#sed command
  sed -n '1,$p' file #1,$ all lines, $ means the last line
  sed -f sed.script file #-f to use sed script
  sed -n -e '/pattern/p' -e '/pattern/=' file #print the line and the line number
  sed '/pattern/ a\strings' file #'a\' append strings after the matched lines
  sed '4 i\strings' file         #'i\' append strings after the line number 4
  sed '/pattern/ c\strings' file #'c\' replace the matched lines with strings
  sed '1,3d' file #delete 1~3lines, '$d' delete last, '//d' delete the matched
  sed '1,3s/old_pattern/new_pattern/g' #replace all matched strings in 1~3lines
  sed 's/str1/str2/w sed.out' file #output the replaced lines into file sed.out
  sed 's/yes/Oh&/p' file #& store yes, so yes is replaced by Ohyes
  sed '/pattern/r input.txt' file #append match lines with content of input.txt
  sed '/pattern/q' file #match the first one then quit
  sed -n '1,$l' file #l(Low case of L) show the control character of all lines
  sed "s/GO/$var/g" #in SHELL script, must use the double quote to use var
  sed 's/^\s\{2,\}//g' #delete the begin space or tab which more than 2 or 2

#sort command
  sort -u source_file > target_file #sort and delete the repeat lines
  sort -t: source_file > target_file #split the line with :
  sort -r source_file > target_file #reverse the sorted lines
  sort -k4 source_file > target_file #sort by the field 4
  head -2 source_file #show the first 2 lines
  tail -2 source_file #show the last 2 lines
  sort -m file1 file2 #merge the 2 files

#uniq, join, cut, paste commands
  uniq [-option] myfile #remove the continuous copy lines
       -u #only show the unrepeated lines
       -c #show the occured numbers
       -d #only show the repeated lines
       -f1, -f2, -f3 ... #ingore the first 1 or 2 or 3 fields
  join file1 file2 #file1 field0 must be same with file2 field0
  join -j1 1 -j2 1 file1 file2 #indicate the same fields position
  join -o 1.1 2.2 file1 file2 #1.1 file1 field0, 2.2 file2 field1
  cut -c1-4 myfile #cut the first four characters
  cut -d: -f3 myfile #use : to split the lines, and get the field 3
  paste -d: file1 file2 #paste the file2 lines after file1 lines with :
  paste -s file1 file2 #two lines, pasts as row, one file one row
  ls | paste - - #list as two columns, '- - -' 3 columns
  split -100 myfile #split it to several files, each file 100 lines

----------------------------------------------------------------------------------------
INT check_subnodes_memory(struct wconfd_subscr_node *subscr_node)
{
    if (subscr_node->sub_num == 0)
    {
        subscr_node->sub_nodes = COS_MALLOC(sizeof(struct wconfd_subscr_node) * SUBNODES_INCREMENT);
    }
    else if (subscr_node->sub_num % SUBNODES_INCREMENT == 0)
    {
        subscr_node->sub_nodes = realloc(subscr_node->sub_nodes, (subscr_node->sub_num + SUBNODES_INCREMENT) * sizeof(struct wconfd_subscr_node));
    }

    return WCONFD_OK;
}

INT check_leafs_memory(struct wconfd_subscr_node *subscr_node)
{
    if (subscr_node->leaf_num == 0)
    {
        subscr_node->leafs = COS_MALLOC(sizeof(struct wconfd_subscr_node) * LEAFS_INCREMENT);
    }
    else if (subscr_node->leaf_num % LEAFS_INCREMENT == 0)
    {
        subscr_node->leafs = realloc(subscr_node->leafs, (subscr_node->leaf_num + LEAFS_INCREMENT) * sizeof(struct wconfd_subscr_node));
    }

    return WCONFD_OK;
}

VOID init_subscr_node(struct confd_cs_node *cs_node, struct wconfd_subscr_node *subscr_node)
{
    if(!cs_node)
        return;

    if(cs_node->info.shallow_type == C_XMLTAG)
    {
        /* create sub node */
        check_subnodes_memory(subscr_node);
        subscr_node->sub_nodes[subscr_node->sub_num].parent_node = subscr_node;
        subscr_node->sub_nodes[subscr_node->sub_num].xml_tag = cs_node->tag;
        if(cs_node->info.flags & CS_NODE_IS_CONTAINER)
            subscr_node->sub_nodes[subscr_node->sub_num].node_type = WCONFD_NODE_CONTAINER;
        if(cs_node->info.flags & CS_NODE_IS_LIST)
        {
            subscr_node->sub_nodes[subscr_node->sub_num].node_type = WCONFD_NODE_LIST;
            subscr_node->sub_nodes[subscr_node->sub_num].list_keys = cs_node->info.keys;
        }
        init_subscr_node(cs_node->children, &subscr_node->sub_nodes[subscr_node->sub_num++]);
    }
    else
    {
        check_leafs_memory(subscr_node);
        struct wconfd_subscr_node leaf;
        memset(&leaf, 0, sizeof(struct wconfd_subscr_node));

        int key_index=0;
        leaf.is_key = FALSE; /* default false */
        if(subscr_node->node_type == WCONFD_NODE_LIST)
        {
            while(subscr_node->list_keys[key_index] != 0)
            {
                if(cs_node->tag ==  subscr_node->list_keys[key_index])
                {
                    leaf.is_key = TRUE;
                    leaf.key_idx = key_index;
                    break;
                }
                key_index++;
            }
        }
        leaf.xml_tag = cs_node->tag;
        leaf.node_type = WCONFD_NODE_LEAF;
        leaf.parent_node = subscr_node;
        memcpy(&subscr_node->leafs[subscr_node->leaf_num++], &leaf, sizeof(struct wconfd_subscr_node));
    }
    init_subscr_node(cs_node->next, subscr_node);
}

VOID init_subscr_info(wconfd_ctx_t *ctx)
{
    if (!ctx->subscr_root)
    {
        ctx->subscr_root = malloc(sizeof(struct wconfd_subscr_node));
        memset(ctx->subscr_root, 0, sizeof(struct wconfd_subscr_node));

        struct confd_cs_node *node = confd_find_cs_root(ctx->namespace);
        init_subscr_node(node, ctx->subscr_root);
    }
}

VOID split_xpath2array(const char *xpath, struct xpath_array_info *array_info)
{
    /* split xpath to tag array */
    int depth = 0;
    char *path = strdup(xpath);
    char *pos1, *pos2;
    char *elem = NULL;

    char *tpath = path;
    while((elem = strtok(tpath, "/")) != NULL)
    {
        if((pos1 = strchr(elem, '{')) != NULL)
        {
            pos2 = COS_STRCHR(pos1, '}');
            COS_STRNCPY(array_info->keys[array_info->keynum++], pos1 + 1, pos2 - (pos1 + 1));
            array_info->keymask |= (1<<depth);
            elem[pos1 - elem] = '\0';
        }
        array_info->tagarr[depth++] = confd_str2hash(elem);
        tpath = NULL;
    }
    free(path);
    array_info->depth = depth;
}

VOID merge_array2xpath(struct xpath_array_info *array_info, char **xpath)
{
    int i=0;
    int len=0;
    int kidx=0;
    if(*xpath == NULL)
    {
        *xpath = COS_MALLOC(MAX_XPATH_LENGTH);
    }
    COS_MEMSET(*xpath, 0, MAX_XPATH_LENGTH);
    while(i<array_info->depth)
    {
        char *tagstr = confd_hash2str(array_info->tagarr[i]);
        if(array_info->keymask & (1<<i))
            sprintf(*xpath+len, "/%s{%s}",tagstr, array_info->keys[kidx++]);
        else
            sprintf(*xpath+len, "/%s",tagstr);
        len = strlen(*xpath);
        (*xpath)[len]='\0';
        i++;
    }
}

struct wconfd_subscr_node* get_subscr_node(struct wconfd_subscr_node *root, struct xpath_array_info *array_info)
{
    int i = 0;
    int depth = 0;
    BOOL isFound = FALSE;
    BOOL isLeaf = FALSE;
    struct wconfd_subscr_node *node = root;

    while(node)
    {
        if(depth < (array_info->depth - 1))
        {
            for(i = 0, isFound = FALSE; i < node->sub_num; i++)
            {
                if(node->sub_nodes[i].xml_tag == array_info->tagarr[depth])
                {
                    isFound = TRUE;
                    break;
                }
            }

            if(isFound)
            {
                depth++; //check next level
                node = &node->sub_nodes[i];
            }
            else
            {
                /*invalid path*/
                return NULL;
            }
        }
        else
        {
            /* break for last check for leaf or container or list */
            break;
        }
    }

    /* check if leaf then set the mask */
    for(i = 0, isLeaf = FALSE; i < node->leaf_num; i++)
    {
        if(node->leafs[i].xml_tag == array_info->tagarr[array_info->depth - 1])
        {
            return (&node->leafs[i]);
        }
    }

    if(!isLeaf) /* the last position is container or list */
    {
        for(i = 0; i < node->sub_num; i++)
        {
            if(node->sub_nodes[i].xml_tag == array_info->tagarr[array_info->depth - 1])
            {
                /* if set mask for container ot list, then effected for all sub elements */
                return (&node->sub_nodes[i]);
            }
        }
    }

    return NULL;
}

struct wconfd_subscr_node*
get_subscr_list_node(struct wconfd_subscr_node *root, struct xpath_array_info *array_info, int list_depth_index)
{
    int i = 0;
    int depth = 0;
    int list_idx = 0;
    BOOL isFound = FALSE;
    struct wconfd_subscr_node *node = root;

    while(node && depth < array_info->depth)
    {
        for(i = 0, isFound = FALSE; i < node->sub_num; i++)
        {
            if(node->sub_nodes[i].xml_tag == array_info->tagarr[depth])
            {
                isFound = TRUE;
                if( node->sub_nodes[i].node_type == WCONFD_NODE_LIST)
                {
                    if(list_idx == list_depth_index)
                    {
                        return &node->sub_nodes[i];
                    }
                    list_idx++;
                }
                break;
            }
        }
        if(isFound)
        {
            depth++;
            node = &node->sub_nodes[i];
            continue;
        }
        return NULL; /* invalid path */
    }

    return NULL;
}

INT set_xpatharray_list_info(struct wconfd_subscr_node *root, struct xpath_array_info *array_info)
{
    int i = 0;
    int depth = 0;
    BOOL isFound = FALSE;
    struct wconfd_subscr_node *node = root;

    while(node && depth < array_info->depth)
    {
        for(i = 0, isFound = FALSE; i < node->sub_num; i++)
        {
            if(node->sub_nodes[i].xml_tag == array_info->tagarr[depth])
            {
                isFound = TRUE;
                if( node->sub_nodes[i].node_type == WCONFD_NODE_LIST)
                {
                    array_info->keynum++;
                    array_info->keymask |= (1 << depth);
                }
                break;
            }
        }
        if(isFound)
        {
            depth++;
            node = &node->sub_nodes[i];
            continue;
        }
        break; /* invalid path */
    }

    return WCONFD_OK;
}

INT set_regist_func_mask(struct wconfd_subscr_node *node, int offset)
{
    int i = 0;
    if(node->node_type == WCONFD_NODE_LEAF || node->node_type == WCONFD_NODE_LIST)
        node->reg_mask_0 |= (1 << offset);

    if(node->node_type == WCONFD_NODE_CONTAINER || node->node_type == WCONFD_NODE_LIST)
    {
        for(i = 0; i < node->leaf_num; i++)
            node->leafs[i].reg_mask_0 |= (1 << offset);

        for(i = 0; i < node->sub_num; i++)
            set_regist_func_mask(&node->sub_nodes[i], offset);
    }
    return WCONFD_OK;
}

BOOL is_xpath_array_exist(wconfd_ctx_t *ctx, struct sub_notify_reg *reg, struct wconfd_subscr_node *node)
{
    int i;
    struct wconfd_subscr_node *node2 = NULL;
    for(i = 0; i < reg->pathnum; i++)
    {
        node2 = get_subscr_node(ctx->subscr_root, &reg->arrays[i]);
        if(node2 == node) /* already exist */
            return TRUE;
    }
    return FALSE;
}

INT fill_xpatharray_info(struct wconfd_subscr_node *node, struct xpath_array_info *array)
{
    int depth=0;
    int idx=0;
    int tag_arr[MAX_XPATH_DEPTH] = {0};
    struct wconfd_subscr_node *tnode = node;
    while(tnode && tnode->xml_tag !=0)
    {
        tag_arr[depth++] = tnode->xml_tag;
        tnode = tnode->parent_node;
    }

    /* reverse the tag array */
    array->depth = depth;
    while(idx<depth)
    {
        array->tagarr[depth-1-idx] = tag_arr[idx];
        idx++;
    }

    /* tnode is ROOT node now */
    return set_xpatharray_list_info(tnode, array);
}

INT add_xpath_arrays(wconfd_ctx_t *ctx, struct sub_notify_reg *reg, struct wconfd_subscr_node *node)
{
    node->reg_mask_0 |= (1 << reg->id);

    if(is_xpath_array_exist(ctx, reg, node))
        return WCONFD_OK;

    struct xpath_array_info array_info;
    COS_MEMSET(&array_info, 0, sizeof(struct xpath_array_info));
    fill_xpatharray_info(node, &array_info);

    if (reg->pathnum == 0)
    {
        reg->arrays = COS_MALLOC(
                                 sizeof(struct xpath_array_info) * XPATHARRAY_INCREMENT);
    }
    else if (reg->pathnum % XPATHARRAY_INCREMENT == 0)
    {
        reg->arrays = realloc(reg->arrays,
                                     (reg->pathnum + XPATHARRAY_INCREMENT) *
                                     sizeof(struct xpath_array_info));
    }

    COS_MEMCPY(&reg->arrays[reg->pathnum++], &array_info, sizeof(struct xpath_array_info));

    return WCONFD_OK;
}

INT add_all_sub_xpath_arrays(wconfd_ctx_t *ctx, struct wconfd_subscr_node *node, struct sub_notify_reg *reg)
{
    int i = 0;

    /* add for leaf and list but not container */
    if(node->node_type == WCONFD_NODE_LEAF || node->node_type == WCONFD_NODE_LIST)
    {
        add_xpath_arrays(ctx, reg, node);
    }

    if(node->node_type == WCONFD_NODE_CONTAINER || node->node_type == WCONFD_NODE_LIST)
    {
        for(i = 0; i < node->leaf_num; i++)
            add_all_sub_xpath_arrays(ctx, &node->leafs[i], reg);

        for(i = 0; i < node->sub_num; i++)
            add_all_sub_xpath_arrays(ctx, &node->sub_nodes[i], reg);
    }
    return WCONFD_OK;
}

INT wconfd_init_config_cb(wconfd_ctx_t *ctx)
{
    ctx->notify_regs = COS_MALLOC(sizeof(struct sub_notify_reg_head));
    if (ctx->notify_regs == NULL)
        return WCONFD_FAIL;

    COS_LIST_INIT(ctx->notify_regs);

    return WCONFD_OK;
}

VOID free_reg_cb(struct sub_notify_reg *reg)
{
    int npath;

    for (npath = 0; reg->xpaths && reg->xpaths[npath]; npath++)
        free(reg->xpaths[npath]);

    COS_FREE(reg);
}

VOID clear_config_cb(struct sub_notify_reg_head *head)
{
    struct sub_notify_reg *reg;
    struct sub_notify_reg *treg;
    COS_LIST_FOREACH_SAFE(reg, head, entry, treg)
    {
        COS_LIST_REMOVE(reg, entry);
        free_reg_cb(reg);
    }
}

VOID wconfd_uninit_config_cb(wconfd_ctx_t *ctx)
{
    clear_config_cb(ctx->notify_regs);
    COS_FREE(ctx->notify_regs);
}

INT register_config_cb(wconfd_ctx_t *ctx, const char **xpaths, wconfd_sub_notify_func func)
{
    int npath = 0;
    struct sub_notify_reg_head *head = ctx->notify_regs;
    struct sub_notify_reg *reg = NULL;

    // count how many paths
    for(npath = 0; xpaths[npath]; npath++)
        ;

    if (npath == 0)
        return WCONFD_FAIL;

    reg = COS_MALLOC(sizeof (struct sub_notify_reg));
    COS_MEMSET(reg, 0, sizeof(struct sub_notify_reg));
    reg->xpaths = COS_MALLOC(sizeof(char *) * npath + 1/*for NULL*/);
    reg->callback = func;

    for (npath = 0; xpaths[npath]; npath++)
        reg->xpaths[npath] = strdup(xpaths[npath]);

    reg->xpaths[npath] = NULL;

    COS_LIST_INSERT_HEAD(head, reg, entry);

    return WCONFD_OK;
}

INT do_register_cb(wconfd_ctx_t *ctx)
{
    int npath;
    int callid = 0;
    char **xpaths = NULL;
    struct sub_notify_reg_head *head = ctx->notify_regs;
    struct sub_notify_reg *reg = NULL;

    COS_LIST_FOREACH(reg, head, entry)
    {
        npath = 0;
        xpaths = reg->xpaths;
        reg->id = callid++;

        while(xpaths[npath]!=NULL)
        {
            struct xpath_array_info array_info; 
            memset(&array_info, 0, sizeof(struct xpath_array_info));
            split_xpath2array(xpaths[npath], &array_info);
            struct wconfd_subscr_node* node =  get_subscr_node(ctx->subscr_root, &array_info);
            if(node)
            {
                if(node->node_type != WCONFD_NODE_CONTAINER)
                    add_xpath_arrays(ctx, reg, node); /* add itself firstly */

                if(node->is_key) /* key leaf set, then set the list reg mask */
                    add_xpath_arrays(ctx, reg, node->parent_node);

                if(node->node_type == WCONFD_NODE_CONTAINER || node->node_type == WCONFD_NODE_LIST)
                    add_all_sub_xpath_arrays(ctx, node, reg);/* add all subs include all list and leaf but not container  */
            }
            npath++;
        }
    }
    
    return WCONFD_OK;
}

BOOL resolve_xpatharray_keys(wconfd_ctx_t *ctx, struct cdb_operations_head  *operations, struct xpath_array_info *array)
{
    int i = 0;
    BOOL is_all_resolved = FALSE;
    struct wconfd_subscr_node *root = ctx->subscr_root;
    struct wconfd_subscr_node *node = NULL;
    struct wconfd_subscr_node *oper_node = NULL;

    for(; i < array->keynum; i++)
    {
        is_all_resolved = FALSE;
        node = get_subscr_list_node(root, array, i);
        if(!node)
            break; /* invalid array */

        struct cdb_operation_node  *oper;
        struct cdb_operation_node  *toper;
        COS_LIST_FOREACH_SAFE(oper, operations, entry, toper)
        {
            oper_node = get_subscr_list_node(root, &oper->xpath_array, i);
            if (node == oper_node)
            {
                COS_STRNCPY(array->keys[i], oper->xpath_array.keys[i], MAX_KEYS_LENGTH);
                is_all_resolved = TRUE;
                break;
            }
        }

        if(!is_all_resolved)
        {
            break; /* break the outer loop if encounter the false condition */
#if 0
            struct xpath_array_info listarray;
            memset(&listarray, 0, sizeof(struct xpath_array_info));
            memcpy(&listarray, array, sizeof(struct xpath_array_info));
            int idx = 0, pos = 0;
            while(idx < listarray.keynum)
            {
                if((1 << pos) & listarray.keymask)
                {
                    if(idx == i)
                        break; //list position found
                    idx++; //list index ++
                }
                pos++;
            }
            listarray.keymask &= ~(1 << pos); //need to serch keys from CDB
            listarray.depth = pos + 1;

            /* cdb get sub nodes */
            char *xpath = NULL;
            merge_array2xpath(&listarray, &xpath);
            cdb_num_instances(ctx->readsock, xpath);
            free(xpath);
#endif
        }
    }
    return is_all_resolved;
}

BOOL get_delete_list_kpath(wconfd_ctx_t *ctx,
                           struct wconfd_subscr_node *node, 
                           struct cdb_operations_head  *operations, 
                           confd_hkeypath_t **kpath)
{
    struct wconfd_subscr_node *root = ctx->subscr_root;
    struct wconfd_subscr_node *oper_node;

    struct cdb_operation_node  *oper;
    struct cdb_operation_node  *toper;
    COS_LIST_FOREACH_SAFE(oper, operations, entry, toper)
    {
        oper_node = get_subscr_node(root, &oper->xpath_array);
        if(oper_node == node)
        {
            /* found the deleted list kpath */
            *kpath = confd_hkeypath_dup(oper->kp);
            return TRUE;
        }
    }
    return FALSE;
}

INT notify_db_changes(wconfd_ctx_t *ctx, struct cdb_operations_head  *operations)
{
    int i = 0;
    int cb_mask = 0;
    struct wconfd_subscr_node *root = ctx->subscr_root;
    struct wconfd_subscr_node *node = NULL;
    struct sub_notify_reg_head *notify_head = ctx->notify_regs;
    struct sub_notify_reg *notify = NULL;
    struct wconfd_db_change *dc = NULL;
    struct wconfd_db_change *tdc = NULL;

    struct cdb_operation_node  *oper;
    struct cdb_operation_node  *toper;
    COS_LIST_FOREACH_SAFE(oper, operations, entry, toper)
    {
        node = get_subscr_node(root, &oper->xpath_array);
        cb_mask |= node->reg_mask_0;
    }

    COS_LIST_FOREACH(notify, notify_head, entry)
    {
        /* Invoke the matched callback */
        if(cb_mask & (1 << notify->id))
        {
            struct wconfd_db_change_head *changes = COS_MALLOC(sizeof(struct wconfd_db_change_head));
            COS_LIST_INIT(changes);
            
            for(i=notify->pathnum-1; i>=0; i--)
            {
                char *nxpath = NULL;
                confd_value_t *nv = NULL;
                confd_hkeypath_t *kpath = NULL;

                /* search by using the path array */
                struct wconfd_subscr_node *subscr_node;
                subscr_node = get_subscr_node(root, &notify->arrays[i]);
                BOOL is_found = FALSE;
                BOOL is_deletion = FALSE;

                COS_LIST_FOREACH_SAFE(oper, operations, entry, toper)
                {
                    struct wconfd_subscr_node *change_node;
                    change_node = get_subscr_node(root, &oper->xpath_array);
                    if(subscr_node == change_node)
                    {
                        /* if the path in operation list */
                        merge_array2xpath(&oper->xpath_array, &nxpath);
                        is_found = TRUE;
                        break;
                    }
                }

                if(!is_found)
                {
                    /* if path not in operation list then get from cdb */
                    if(notify->arrays[i].keymask != 0)
                    {
                        struct xpath_array_info resolved_array;
                        memcpy(&resolved_array, &notify->arrays[i], sizeof(struct xpath_array_info));
                        if(resolve_xpatharray_keys(ctx, operations, &resolved_array)==FALSE)
                            continue;
                        merge_array2xpath(&resolved_array, &nxpath);
                    }
                    else /* no keys */
                    {
                        merge_array2xpath(&notify->arrays[i], &nxpath);
                    }

                    /* get cdb */
                    confd_value_t tmpv;
                    if(cdb_get(ctx->readsock, &tmpv, nxpath) == CONFD_OK) //value get success
                    {
                        nv = confd_value_dup(&tmpv);
                        confd_free_value(&tmpv);
                        /* get key path if nxpath is valid */
                        cdb_pushd(ctx->readsock, nxpath);
                        cdb_getcwd_kpath(ctx->readsock, &kpath);
                        cdb_popd(ctx->readsock);
                    }
                    else /* else error when get from CDB with path */
                    {
                        /* for list delete, then sub item does not exist */
                        if(subscr_node->is_key /* key leaf of LIST */
                            && get_delete_list_kpath(ctx, subscr_node->parent_node, operations, &kpath))
                        {
                            /* set the nv of key val */
                            nv = confd_value_dup(&kpath->v[0][subscr_node->key_idx]);
                            
                            /* fix the keypath with leaf */
                            int kidx = kpath->len;
                            while(kidx>0)
                            {
                                COS_MEMCPY(kpath->v[kidx], kpath->v[kidx-1], sizeof(confd_value_t)*MAXKEYLEN);
                                kidx--;
                            }

                            COS_MEMSET(kpath->v[0], 0, sizeof(confd_value_t)*MAXKEYLEN);
                            kpath->v[0][0].type = C_XMLTAG;
                            kpath->v[0][0].val.xmltag.tag = subscr_node->xml_tag;
                            kpath->v[0][0].val.xmltag.ns = ctx->namespace;
                            

                            kpath->len++;
                            
                            
                            /* set deletion flag */
                            is_deletion = TRUE;
                        }
                        else
                        {
                            /* skip the other item which not exists */
                            free(nxpath);
                            continue;
                        }
                    }
                }
                free(nxpath);

                /* insert the new change node  */
                struct wconfd_db_change *ndc;
                ndc = COS_MALLOC(sizeof (struct wconfd_db_change));
                COS_MEMSET(ndc,0,sizeof(struct wconfd_db_change));
                if(!is_found)
                {
                    if(is_deletion) /* key leaf when delete list */
                        ndc->opertype = WCONFD_OPER_DELETION;
                    else
                        ndc->opertype = WCONFD_OPER_NOCHANGE;
                    ndc->nodetype = WCONFD_NODE_LEAF;
                    ndc->kpath = kpath;
                    ndc->newval = nv;
                    ndc->oldval = NULL;
                }
                else /* from oper list which need to duplicate */
                {
                    ndc->opertype = oper->oper_type;
                    ndc->nodetype = subscr_node->node_type;

                    if(subscr_node->node_type == WCONFD_NODE_LIST)
                        continue; /* Skip to add to List whatever it is creae or delete */

                    if(subscr_node->is_key) /* Key leaf can be seen in opers only when creation */
                        ndc->opertype = WCONFD_OPER_CREATION;

                    if(oper->new_value != NULL)
                        ndc->newval = confd_value_dup(oper->new_value);
                    if(oper->old_value != NULL)
                        ndc->oldval = confd_value_dup(oper->old_value);
                    if(oper->kp != NULL)
                        ndc->kpath = confd_hkeypath_dup(oper->kp);
                }
                COS_LIST_INSERT_HEAD(changes, ndc, entry);
            }

            /* invoke the callback func*/
            if(notify->callback)
            {
                notify->callback(changes);
            }

            /* free the db change list*/
            COS_LIST_FOREACH_SAFE(dc, changes, entry, tdc)
            {
                if(dc->newval)
                    confd_free_value(dc->newval);
                if(dc->oldval)
                    confd_free_value(dc->oldval);
                if(dc->kpath)
                    confd_free_hkeypath(dc->kpath);
                COS_LIST_REMOVE(dc, entry);
                COS_FREE(dc);
            }
            COS_FREE(changes);
        }
    }
    return WCONFD_OK;
}

static enum cdb_iter_ret wconfd_cdb_iter(confd_hkeypath_t *kp,
                                         enum cdb_iter_op op,
                                         confd_value_t *oldv,
                                         confd_value_t *newv,
                                         void *state)
{
    char xpath[BUFSIZ];

    struct cdb_operations_head *head = (struct cdb_operations_head*)state;
    struct cdb_operation_node *node = malloc(sizeof(struct cdb_operation_node));
    memset(node, 0, sizeof(struct cdb_operation_node));

    node->kp = confd_hkeypath_dup(kp);
    confd_pp_kpath(xpath, BUFSIZ, kp);
    split_xpath2array(xpath, &node->xpath_array);

    COS_LIST_INSERT_HEAD(head, node, entry);
    
    switch (op)
    {
        case MOP_CREATED:
            node->oper_type = WCONFD_OPER_CREATION;
            break;
        case MOP_DELETED:
            node->oper_type = WCONFD_OPER_DELETION;
            break;
        case MOP_MODIFIED:
            node->oper_type = WCONFD_OPER_MODIFICATION;
            break;
        case MOP_VALUE_SET:
            node->oper_type = WCONFD_OPER_SETVALUE;
            if(oldv)
            {
                node->old_value = confd_value_dup(oldv);
            }
            node->new_value = confd_value_dup(newv);
            break;
        default:
            printf("should never run here!\n");
            break;
    }
    return ITER_RECURSE;
}

